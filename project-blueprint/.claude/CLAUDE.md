# 開発ガイド

プロジェクト横断で適用する開発ルール・品質基準・ワークフロー。
全ロール（PM / PdM / 開発 / レビュー / テスト）共通で参照する。

> **プロジェクト固有のパラメータ**: `project-config.md` に集約。
> 技術スタック・ルーティング・データモデル等の詳細は `docs/` 配下を参照。

## 全般

- 必ず日本語で応対する
- 調査やデバッグにはサブエージェントを活用してコンテキストを節約する
- 重要な決定事項は定期的にマークダウンファイルに記録する
- CLAUDE.md は横断ルールのみ記載し、詳細な手順はスキルに委譲する
- 利用可能なスキル（全スキル引数は省略可能。省略時は対話的に確認する）:
  - `/plan <説明 or ファイルパス>` — 設計ドキュメント生成（読み取り専用、実装不可）
  - `/implementing-features <タスクファイル or 指示>` — TDDによる機能実装・バグ修正
  - `/ui-ux-design <対象ファイル or 指示>` — デザインシステム準拠のUI/UX設計・レビュー・実装
  - `/e2e-testing <対象機能 or 指示>` — Playwright E2Eテスト作成
  - `/code-review <対象ファイル or 指示>` — コードレビュー（読み取り専用）
  - `/performance <対象 or 指示>` — 計測ファーストのパフォーマンス最適化
  - `/refactoring <対象ディレクトリ or 指示>` — 安全な段階的リファクタリング
  - `/legal-check <対象範囲 or 指示>` — IT法務観点のコンプライアンスチェック（読み取り専用）
  - `/security-scan <対象範囲 or 指示>` — セキュリティスキャン・脆弱性レポート（読み取り専用）
  - `/prd <ファイルパス>` — 要求メモからPRD生成（読み取り専用）
  - `/architecture <ファイルパス>` — 要求メモからアーキテクチャ設計（読み取り専用）
- スキル選定の判断基準:
  - 新機能実装 → `/implementing-features <タスクファイル>`
  - UI調整・ダークモード・a11y → `/ui-ux-design <対象ファイル>`
  - 大きな変更の事前設計 → `/plan <説明>`
  - PR前の品質確認 → `/code-review <対象ファイル>`
  - ユーザーフローの自動テスト → `/e2e-testing <対象機能>`
  - パフォーマンス改善・バンドル最適化 → `/performance <対象>`
  - 大規模コード再構成・責務移動 → `/refactoring <対象ディレクトリ>`
  - OSSライセンス・プライバシー・知的財産の法務チェック → `/legal-check <対象範囲>`
  - 脆弱性スキャン・OWASP ZAP・依存パッケージ監査 → `/security-scan <対象範囲>`
  - 要求メモ・要件メモからPRD作成 → `/prd <ファイルパス>`
  - 要求メモからシステムアーキテクチャ設計 → `/architecture <ファイルパス>`

## ドキュメント管理方針

### 人間が管理するファイル

- `project-config.md` — 技術選定・品質基準・ポリシー等、人間が決定すべきパラメータ

### AI が管理するファイル

以下のファイルはAIが生成・メンテナンスする。実装変更に伴い自動的に更新する:

- `docs/project.md` — ルーティング・ストア一覧・コマンド・技術スタック
- `docs/architecture.md` — ディレクトリ構成・テスト一覧
- `docs/data-model.md` — スキーマ定義・バリデーションルール
- `docs/development-patterns.md` — コード規約・落とし穴・デザインシステム

### project-config.md の AI メンテナンス

各スキルは設計・実装の進行に伴い、`project-config.md` の以下セクションを更新する:

| 更新トリガー                           | 対象セクション                    |
| -------------------------------------- | --------------------------------- |
| 新しい落とし穴・アンチパターンの発見   | §11（既知の落とし穴）            |
| 依存パッケージの追加・バージョン変更   | §2（技術スタック）               |
| コマンドの追加・変更                   | §3（コマンド）                   |

`project-config.md` と `docs/` の整合性を常に保つこと。

### project-config.md 更新の競合防止

| セクション | 一次更新責務 | ルール |
| ---------- | ------------ | ------ |
| §2（技術スタック） | `/implementing-features` | 他スキルは発見事項を報告し、一次更新者が集約 |
| §3（コマンド） | `/implementing-features` | 同上 |
| §4（アーキテクチャ） | `/implementing-features` | `/architecture` は `output/design/` に出力。採用後に反映 |
| §11（既知の落とし穴） | 全スキル（追記可） | 追記前に既存エントリの重複を確認すること |

### docs/ 更新の競合防止

| ファイル | 一次更新責務 | ルール |
| -------- | ------------ | ------ |
| `docs/project.md` | `/implementing-features` | ルーティング・ストア・コマンド変更時に更新 |
| `docs/architecture.md` | `/implementing-features` | ディレクトリ構成・テスト配置の変更時に更新。`/architecture` は `output/design/` に出力し、採用後に反映 |
| `docs/data-model.md` | `/implementing-features` | スキーマ追加・変更時に更新 |
| `docs/development-patterns.md` | `/implementing-features` | コード規約・落とし穴・デザインシステムの変更時に更新。他スキル（`/performance`, `/refactoring` 等）は発見事項をPLまたは会話内で報告し、一次更新者が集約 |

チームコンテキストでは、PLが `project-config.md` および `docs/` の更新を一元管理する。メンバーは発見事項をPLにメッセージで報告し、PLが更新する。§11への追記のみメンバーが直接実施可能（重複チェック必須）。

## 開発原則

- 仕様が曖昧な場合は推測で進めず、具体的な選択肢を1〜2つ提示して確認する
- 仕様に選択肢があればそれに従い、なければもっとも単純な選択肢を選び仮定であることを明示する
- ユーザーデータの削除・上書きは仕様で明示的に要求された場合のみ
- 保存値と表示値が区別される場合はデータモデルとUIで分離する
- 決定論的であること。丸めモード、フォーマット、集計スコープを明確に定義する
- 過剰設計を避ける。現在の要件に必要な最小限の複雑さで実装する
- コードから読み取れる情報をドキュメントに重複させない

## アーキテクチャガバナンス

レイヤー間の依存方向を制限する。ルールの詳細は `project-config.md` セクション4.4 に定義。

- 依存方向違反は検出コマンド（`project-config.md` に記載）で確認する
- 循環依存は禁止

## 品質基準

- テストファースト（TDD）で段階的に実装する（`project-config.md` セクション6 で有効化時）
- 重要なビジネスロジックにはユニットテストを用意する
- 主要ユーザーフローはE2Eテストでカバーする
- テストカバレッジ目標は `project-config.md` セクション6 に定義

## 品質レポートとゲート

- 各工程の完了時に品質の証跡を人間が判読可能な形式で提示する。
- 品質ゲートは人間が介在できるポイントとして設けるが、介在は任意とする。
- レポートは用途に応じて2つのディレクトリに分離する（`project-config.md` セクション6.1 参照）
- ゲートには2種類ある:
  - **スキルゲート（3つ）**: 各スキル実行中の設計/実装/最終チェックポイント
  - **フェーズゲート（5つ）**: PJMチームのフェーズ間承認ポイント（`.claude/teams/TEAM_PJM.md` 参照）

### レポート出力先

レポートは **ツール直接出力**（機械向け）と **人間向けサマリー**（レビュー用）に分離する:

| 種別 | 出力先 | 内容 | 例 |
| ---- | ------ | ---- | -- |
| ツール直接出力 | `testreport/` | ツールが生成する生データ（HTML/JSON/LCOV等） | カバレッジHTML、ZAPレポート、gitleaks JSON |
| 人間向けサマリー | `output/reports/` | 人間がレビューするMarkdownレポート | コードレビュー結果、法務チェック結果 |

#### ツール直接出力（`testreport/`）

| カテゴリ | 出力先 | 生成スキル |
| -------- | ------ | ---------- |
| ユニットテストカバレッジ | `testreport/coverage/` | `/implementing-features` |
| E2Eテストレポート | `testreport/e2e/` | `/e2e-testing` |
| セキュリティスキャン | `testreport/security/` | `/security-scan` |

#### 人間向けサマリー（`output/reports/`）

| カテゴリ | 出力先 | 生成スキル |
| -------- | ------ | ---------- |
| コードレビュー | `output/reports/review/` | `/code-review` |
| テスト結果サマリー | `output/reports/test/` | `/e2e-testing` |
| セキュリティサマリー | `output/reports/security/` | `/security-scan` |
| 法務チェック | `output/reports/legal/` | `/legal-check` |

### レポート内容

工程の完了時に以下をサマリーとして報告する:

- テスト結果（pass / fail件数、失敗テストの原因）
- カバレッジ（行・分岐の変動、閾値との差分）
- 静的解析（lint / 型チェックの警告・エラー数）
- 変更の影響範囲（変更ファイル数、影響を受けるテスト数）

### ゲートポイント

以下のタイミングで結果を提示し、人間が確認・判断できる状態にする:

1. **設計完了時**: 要件の解釈・テスト設計方針を提示。承認後に実装へ進む
2. **実装完了時**: テスト結果・カバレッジ・静的解析のサマリーを提示
3. **最終確認**: 全チェックリスト項目の充足状況を一覧で提示

ゲートの通過基準:

- テストが全件パスしていること
- カバレッジが目標値を下回っていないこと
- 静的解析のエラーが0件であること
- 上記を満たせば自動通過。満たさない場合は人間の判断を仰ぐ

## 並行開発の原則

- 変更はファイル単位で衝突を回避する。同一ファイルの同時編集は行わない
- 共有レイヤーの変更は逐次で行う
- 大きな機能追加は `/plan` スキルで事前にタスク分解し、並行可能な単位を特定する
- 並行タスク間の依存関係を明示し、ブロッキングを最小化する
- Agent Teams使用時は`.claude/teams/`配下のチームテンプレートに従う（全チーム引数は省略可能。省略時はPLが対話的に確認する）
  - フルライフサイクル → `TEAM_PJM.md <要求メモファイル or 指示>`（全11スキル、推奨）
  - フルライフサイクル（並行実装） → `TEAM_PJM.md <要求メモファイル or 指示> --parallel`（独立タスク群をTEAM_FEATUREに並行委任。`--auto`と併用可）
  - 機能開発 → `TEAM_FEATURE.md <タスクファイル or 実装指示>`
  - 品質保証 → `TEAM_QA.md <対象範囲 or QA指示>`
  - 設計フェーズ → `TEAM_PLANNING.md <要求メモファイル or 設計指示>`
  - リファクタリング → `TEAM_REFACTOR.md <対象ディレクトリ or リファクタリング指示>`
- PJMチームは`input/`のメモを読み、`output/`に成果物を生成する
- PLがタスク分解・依存関係設定・割り当てを行い、メンバーは割り当てタスクのみ実装する
- 共有レイヤーの変更はPLが逐次割り当てし、並行編集を回避する

## 実装ワークフロー

1. 要件確認: 曖昧さがあれば選択肢を提示して解消する
2. 影響調査: 既存コード・テスト・依存関係を確認する
3. テスト設計: 受け入れ基準からテストケースを導出する
4. **🚏 設計ゲート**: 要件解釈とテスト方針を提示し、確認を待つ
5. 実装: テストを通す最小限のコードを書く
6. リファクター: 重複排除・可読性改善（テストグリーンを維持）
7. **🚏 実装ゲート**: テスト結果・カバレッジ・静的解析のサマリーを提示
8. セルフレビュー: 下記チェックリストで検証する
9. **🚏 最終ゲート**: チェックリスト充足状況を一覧で提示

## 実装チェックリスト

設計・コードの提出前に確認すること:

- [ ] データモデル/スキーマの変更点を明記した
- [ ] UIの動作（編集可能vs読み取り専用）を定義した
- [ ] コアアルゴリズム（丸め、書式設定、集計）を明確にした
- [ ] 受け入れ基準との対応を示した
- [ ] 既存テストが壊れていないことを確認した
- [ ] エッジケース（空配列、境界値、null）を考慮した
- [ ] 実装変更に伴い `docs/` 配下のドキュメントを更新した
- [ ] 依存方向ルールに違反していないことを確認した
- [ ] `--no-verify` を使用していないことを確認した

## コミュニケーション規約

- 技術的判断には根拠を必ず添える
- 仕様変更が必要な場合は影響範囲を提示してから着手する
- レビュー指摘には修正内容と理由をセットで回答する
- 不確実な仮定は「【仮定】」と明示する

## ツール利用方針

- ドキュメント参照の優先順位:
  1. プロジェクト内の `docs/` ファイル
  2. `WebFetch` で公式サイトを直接参照
  3. Context7 MCP（公式サイトで不十分な場合のみ）
  4. `WebSearch`（最新情報が必要な場合のみ）
- Playwright MCP: E2Eテストのデバッグ・ビジュアル確認に使用
- draw.io MCP: アーキテクチャ図・フロー図の作成に使用

## セキュリティ強化

セキュリティポリシーの詳細は `project-config.md` セクション10 に定義。
以下は全プロジェクト共通:

- ユーザー入力は必ずバリデーションする
- 依存パッケージの脆弱性を定期確認する
- **フックベース安全機構**: `.claude/hooks/` の PreToolUse フックが危険な Bash コマンドと機密ファイルへの書き込みをブロックする。このフックは `--dangerously-skip-permissions` モードでも有効（多層防御）

## Git操作ポリシー

- `--no-verify` は禁止（フックを迂回しない）
- `--force` は原則禁止（必要な場合は理由を明示し確認を取る）
- フック失敗時はエラーの原因を修正する（フックを無効化しない）
- Git Hooks の構成は `project-config.md` セクション9 に定義

## プロジェクト固有情報

推奨読み込み順: `project-config.md`（人間の決定事項）→ `docs/`（AI生成の詳細仕様）→ 本ファイル（横断ルール）

@docs/project.md              <!-- 技術スタック・コマンド・ルーティング・ストア一覧 -->
@docs/architecture.md          <!-- ディレクトリ構成・テスト一覧・ドキュメント責務 -->
@docs/data-model.md            <!-- スキーマ定義・フィールド仕様・バリデーション -->
@docs/development-patterns.md  <!-- コード規約・落とし穴・デザインシステム -->

## ワークフロー制御

### 1. 計画ファースト
- 非自明なタスク（3ステップ以上 or アーキテクチャ判断を伴う）は必ず計画モードで開始する
- 想定外の問題が発生したら即座に計画を見直す — そのまま突き進まない
- 検証ステップも計画に含める（実装だけでなく確認手順も設計する）
- 曖昧さを減らすために、事前に詳細な仕様を書き出す

### 2. サブエージェント戦略
- メインコンテキストを圧迫しないよう、サブエージェントを積極的に使う
- 調査・探索・並行分析はサブエージェントに委譲する
- 複雑な問題にはサブエージェントで計算資源を集中投入する
- 1サブエージェント = 1タスクで、焦点を絞って実行する

### 3. 自己改善ループ
- ユーザーから修正を受けたら、`.claude/tasks/LESSONS_TEMPLATE.md` の形式で学びを記録する
- 同じミスを繰り返さないルールを自分で書く
- ミス率が下がるまで学びを反復的に改善する
- セッション開始時に関連プロジェクトの学びを確認する

### 4. 完了前の検証
- 動作を証明せずにタスクを完了にしない
- 必要に応じてmainブランチとの差分を比較する
- 「シニアエンジニアがこれを承認するか？」と自問する
- テスト実行・ログ確認・正しさの実証を行う

### 5. エレガンスの追求（バランス型）
- 非自明な変更では「もっとエレガントな方法はないか？」と立ち止まる
- ハック的な修正に感じたら「すべてを知った上で、エレガントな解決策を実装する」
- 単純で明白な修正にはこれを適用しない — 過剰設計を避ける
- 提出前に自分の成果物を批判的にレビューする

### 6. 自律バグ修正
- バグ報告を受けたら、手取り足取りの指示を求めず自力で修正する
- ログ・エラー・失敗テストを特定し、解決する
- ユーザーのコンテキストスイッチをゼロにする
- CI失敗も指示を待たず自律的に修正する

## タスク管理

1. **計画を立てる**: Claude Code の `TaskCreate` / `TaskUpdate` でチェック可能な項目を作成する
2. **計画を確認する**: 実装開始前にチェックインする
3. **進捗を追跡する**: 完了した項目を随時マークする
4. **変更を説明する**: 各ステップでハイレベルなサマリーを提示する
5. **結果を記録する**: 完了時にレビューセクションを追加する
6. **学びを蓄積する**: 修正を受けたら `.claude/tasks/LESSONS_TEMPLATE.md` の形式で学びを記録する

## 基本原則

- **シンプルさ優先**: すべての変更を可能な限りシンプルにする。影響範囲を最小限に抑える
- **妥協しない**: 根本原因を特定する。一時的な修正は行わない。シニア開発者の基準で判断する
- **影響を最小化する**: 変更は必要な箇所のみに留める。バグを持ち込まない